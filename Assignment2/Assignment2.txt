Reference the syntactic structure of Cool, found in Figure 1 of The Cool Reference Manual


+] cool.y 
This file contains a start towards a parser description for Cool. The declaration section is mostly complete, but you will need to add additional type declarations for new nonterminals you introduce. We have given you names and type declarations for the terminals. You might also need to add precedence declarations. The rule section, however, is rather incomplete. We have provided some parts of some rules. You should not need to modify this code to get a working solution, but you are welcome to if you like. However, do not assume that any particular rule is complete.

+] good.cl and bad.cl
These files test a few features of the grammar. Feel free to modify these files to test your parser.


cool.y is the skeleton for the parser specification that you
are to write. It already contains productions for the program
and the classes. Use them as an example to write the remaining
productions.  You should also read the bison documentation.
This skeleton will compile and run as is, but it doesn't
do much.

good.cl, bad.cl test a few features of the grammar. You should
add tests to ensure that good.cl exercises every legal
construction of the grammar and that bad.cl exercises as many
different parsing errors as you can squeeze into one file.

cool-tree.aps contains the definitions for the tree language
which you use to construct the abstract syntax tree (AST).
From this file, cool-tree.h and cool-tree.cc are automatically
generated by a utility that compiles the specification into
C++ functions for producing and consuming the tree nodes.
This file is provided for your reference.  DO NOT MODIFY.

tree.{cc|h} contain definitions used by the tree package.
cool-tree.handcode.h is the handwritten extension to
cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
note that there are "hooks" for extending the classes
declarations.  Extending and modifying the tree package is
discussed in the "Cool Tour", but you do not need to (and should
not) modify the tree package for this assignment.

tokens-lex.cc is a lexer capable of reading a token stream from
console in the format produced by the lexer phase. DO NOT
MODIFY.

parser-phase.cc contains a driver to test the parser. DO NOT
MODIFY.

dumptype.cc prints the AST out in a form readable by the
semant phase of the compiler. DO NOT MODIFY.

handle_flags.cc implements routines for parsing command line
flags. DO NOT MODIFY.

The rest of the files are created as byproducts of `bison'.
`cool-parse.cc' is the generated C++ file containing the
parser.




		To compile your parser program type:

        % make parser

        This produces an executable named "parser" which is standalone
        phase of the Cool compiler.  It requires lexer, semant, and cgen
        to do anything useful.

        To test your parser on a file 'foo.cl' type

        % myparser foo.cl

        myparser is a shell script that "glues" together lexer and
        parser using pipes.

        To run your parser on the files good.cl and bad.cl type:

        % make dotest

        To run the (provided) lexer and your parser on a file called test.cl type:

        % ./lexer test.cl | ./parser
		
		
		If you think your parser is correct and behaves like
        the one we wrote, you may want to run a COOL compiler using
        your parser:

        % mycoolc foo.cl

        To overwrite the default lexical analyzer with yours, replace
        lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.


        Instructions for turning in the assignment will be posted on the
        course web page.

        GOOD LUCK!

		
		
To receive full credit, your parser should recover in at least the following situations:

• If there is an error in a class definition but the class is terminated properly and the next class is
syntactically correct, the parser should be able to restart at the next class definition.

• Similarly, the parser should recover from errors in features (going on to the next feature), a let binding
(going on to the next variable), and an expression inside a {...} block.




You must declare bison “types” for your non-terminals and terminals that have attributes. For example,
in the skeleton cool.y is the declaration:

%type <program> program

This declaration says that the non-terminal program has type <program>. The use of the word “type” is misleading here; what it really means is that the attribute for the non-terminal program is stored in the program member of the union declaration in cool.y, which has type Program




<expr>.<id>(<expr>,...,<expr>)
<id>(<expr>,...,<expr>)
<expr>@<type>.id(<expr>,...,<expr>)
